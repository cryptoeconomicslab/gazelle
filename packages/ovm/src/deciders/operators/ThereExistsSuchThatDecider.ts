import { Bytes } from '@cryptoeconomicslab/primitives'
import { getWitnesses, isHint, replaceHint } from '@cryptoeconomicslab/db'
import { Decider } from '../../interfaces/Decider'
import { DeciderManager } from '../../DeciderManager'
import { Property, LogicalConnective } from '../../types'
import { TraceInfoCreator } from '../../Tracer'

/**
 * ThereExists decides property to true if any quantified value fulfill proposition.
 * inputs: Array<Bytes> [HintString, variableName, Property]
 * If any decision prove true, ThereExistsSuchThatDecider returns its variable as witness.
 * This witness is appended to the witnesses generated by the child property.
 * If there are no true decisions, it should return valid challenge as challenges.
 * The valid challenge of ThereExistsSuchThat(P) is ForAllSuchThat(Not(P))
 */
export class ThereExistsSuchThatDecider implements Decider {
  public async decide(
    manager: DeciderManager,
    inputs: Bytes[],
    substitutions: { [key: string]: Bytes } = {}
  ) {
    const { coder } = ovmContext
    let witnesses: Bytes[]
    if (isHint(inputs[0])) {
      witnesses = await getWitnesses(
        manager.witnessDb,
        replaceHint(inputs[0].intoString(), substitutions)
      )
    } else {
      throw new Error('inputs[0] must be valid hint data.')
    }
    const innerProperty = Property.fromStruct(
      coder.decode(Property.getParamType(), inputs[2])
    )
    const variableName = inputs[1].intoString()

    const decisions = await Promise.all(
      witnesses.map(async variable => {
        return await manager.decide(innerProperty, {
          ...substitutions,
          [variableName]: variable
        })
      })
    )
    const index = decisions.findIndex(d => d.outcome)
    const childTraceInfo = decisions.find(d => d.outcome === false)?.traceInfo
    const challenge = {
      challengeInput: null,
      property: new Property(
        manager.getDeciderAddress(LogicalConnective.ForAllSuchThat),
        [
          inputs[0],
          inputs[1],
          coder.encode(
            new Property(manager.getDeciderAddress(LogicalConnective.Not), [
              inputs[2]
            ]).toStruct()
          )
        ]
      )
    }

    if (index >= 0) {
      // If any decision prove true
      let nextWitnesses: Bytes[] | undefined = undefined
      const witness = witnesses[index]
      const childWitnesses = decisions[index].witnesses || []
      nextWitnesses = childWitnesses.concat([witness])
      return {
        outcome: true,
        witnesses: nextWitnesses,
        challenges: []
      }
    } else {
      // If there are no true decisions
      return {
        outcome: false,
        witnesses: [],
        challenges: [challenge],
        traceInfo: childTraceInfo
          ? TraceInfoCreator.createThere(childTraceInfo)
          : undefined
      }
    }
  }
}
